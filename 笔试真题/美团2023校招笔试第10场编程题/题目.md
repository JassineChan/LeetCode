# 淘汰分数

## 问题描述
某比赛已经进入了淘汰赛阶段，已知共有 `n` 名选手参与了此阶段比赛，他们的得分分别是 `a_1, a_2, ..., a_n`。小美作为比赛的裁判希望设定一个分数线 `m`，使得所有分数大于 `m` 的选手晋级，其他人淘汰。

为了保护粉丝脆弱的心脏，小美希望晋级和淘汰的人数均在 `[x, y]` 之间。

显然，这个 `m` 有可能是不存在的，也有可能存在多个 `m`：
- 如果不存在，请输出 `-1`。
- 如果存在多个，请输出符合条件的最低的分数线。

## 数据范围
- `1 ≤ n ≤ 50000`
- `1 ≤ x ≤ y ≤ n`
- `1 ≤ a_i ≤ 10^9`

## 进阶要求
- 时间复杂度：`O(n log n)`
- 空间复杂度：`O(n)`

## 输入描述
- 第一行包含三个整数 `n, x, y`，分别表示选手人数、晋级和淘汰人数的范围。
- 第二行包含 `n` 个整数，表示选手的得分 `a_1, a_2, ..., a_n`。

## 输出描述
- 如果不存在符合条件的分数线，输出 `-1`。
- 如果存在多个符合条件的分数线，输出符合条件的最低分数线。


# 正则序列

## 问题描述
我们称一个长度为 `n` 的序列为正则序列，当且仅当该序列是一个由 `1~n` 组成的排列，即该序列由 `n` 个正整数组成，取值在 `[1, n]` 范围，且不存在重复的数，同时正则序列不要求排序。

有一天小团得到了一个长度为 `n` 的任意序列 `s`，他需要在有限次操作内，将这个序列变成一个正则序列，每次操作他可以任选序列中的一个数字，并将该数字加一或者减一。

请问他最少用多少次操作可以把这个序列变成正则序列？

## 数据范围
- `1 ≤ n ≤ 20000`
- `0 ≤ abs(s_i) ≤ 10000`

## 进阶要求
- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

## 输入描述
- 第一行包含一个整数 `n`，表示序列的长度。
- 第二行包含 `n` 个整数，表示序列 `s`。

## 输出描述
- 输出一个整数，表示将序列变成正则序列所需的最少操作次数。


# 公司食堂

## 问题描述
小美和小团所在公司的食堂有 `N` 张餐桌，从左到右摆成一排，每张餐桌有 2 张餐椅供至多 2 人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：

- 当男职员进入食堂时，他会优先选择已经坐有 1 人的餐桌用餐，只有当每张餐桌要么空着要么坐满 2 人时，他才会考虑空着的餐桌；
- 当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少 1 人时，她才会考虑已经坐有 1 人的餐桌；
- 无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。

现在食堂内已有若干人在用餐，另外 `M` 个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌。

## 数据范围
- `1 ≤ N, M ≤ 100000`

## 输入描述
- 第一行包含两个整数 `N` 和 `M`，分别表示餐桌数量和排队人数。
- 第二行包含一个长度为 `N` 的字符串，表示当前每张餐桌的状态：
    - `'0'` 表示该餐桌空着；
    - `'1'` 表示该餐桌已有 1 人；
    - `'2'` 表示该餐桌已有 2 人。
- 第三行包含一个长度为 `M` 的字符串，表示排队人员的性别：
    - `'M'` 表示男职员；
    - `'F'` 表示女职员。

## 输出描述
- 输出一行，包含 `M` 个整数，表示排队的每个人分别会坐的餐桌编号（从 1 开始）。

## 进阶要求
- 时间复杂度：`O(n log n)`
- 空间复杂度：`O(n)`


# 最优二叉树II

## 问题描述
小团有一个由 `N` 个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了 `N` 个数，第 `i` 个数表示位于中序遍历第 `i` 个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。

## 数据范围
- `1 ≤ N ≤ 100000`
- `1 ≤ 节点权值 ≤ 10000`

## 输入描述
- 第一行包含一个整数 `N`，表示节点的数量。
- 第二行包含 `N` 个整数，表示按照中序遍历记录的节点权值。

## 输出描述
- 输出一个整数，表示最优二叉树的总开销。
